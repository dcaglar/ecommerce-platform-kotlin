# Single-node, controller+broker in one pod; plaintext listeners; single-node-friendly internals.

listeners:
  client: {protocol: PLAINTEXT, containerPort: 9092, name: CLIENT}
  controller: {protocol: PLAINTEXT, containerPort: 9093, name: CONTROLLER}
  interbroker: {protocol: PLAINTEXT, containerPort: 9094, name: INTERNAL}

controller:
  replicaCount: 1
  controllerOnly: false
  # ✅ Resources for the Kafka container (fix OOMKills)
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
      # Optional; if you see eviction due to local disk, set this:
      # ephemeral-storage: 1Gi
    limits:
      cpu: "1"
      memory: 2Gi
      # Optional; raise or remove if you don't want a hard cap on local disk:
      # ephemeral-storage: 4Gi

  # ✅ Pin JVM heap so it fits inside the container limit
  # (Use the key your chart supports; many charts use extraEnv, some use env)
  extraEnv:
    - name: KAFKA_HEAP_OPTS
      value: "-Xms512m -Xmx512m"
    # Reasonable JVM perf defaults for Kafka on small nodes
    - name: KAFKA_JVM_PERFORMANCE_OPTS
      value: "-XX:+UseG1GC -XX:MaxGCPauseMillis=200 -XX:+ExplicitGCInvokesConcurrent"
  overrideConfiguration:
    # Roles & listeners
    auto.create.topics.enable: false
    process.roles: controller,broker
    controller.listener.names: CONTROLLER
    inter.broker.listener.name: INTERNAL
    listeners: CLIENT://:9092,INTERNAL://:9094,CONTROLLER://:9093
    listener.security.protocol.map: CLIENT:PLAINTEXT,INTERNAL:PLAINTEXT,CONTROLLER:PLAINTEXT
    advertised.listeners: >
      CLIENT://kafka.payment.svc.cluster.local:9092,
      INTERNAL://kafka-controller-0.kafka-controller-headless.payment.svc.cluster.local:9094

    # Single-node defaults (safe in dev)
    num.partitions: 1
    min.insync.replicas: 1

    # Make internal topics 1/1 so Kafka won't expect a 3-node quorum
    offsets.topic.replication.factor: 1
    offsets.topic.num.partitions: 1
    transaction.state.log.replication.factor: 1
    transaction.state.log.min.isr: 1
    transaction.state.log.num.partitions: 1
    # Kafka 4.x also logs this one; keep it small in single node
    share.coordinator.state.topic.num.partitions: 1

broker:
  # No separate broker-only set for single-node
  replicaCount: 0

# Avoid surprises with policies in local clusters
networkPolicy:
  enabled: false

metrics:
  kafka:
    enabled: false
defaultInitContainers:
  prepareConfig:
    resources:
      requests: {cpu: 50m, memory: 64Mi}
      limits: {cpu: 200m, memory: 128Mi}