app:
  instance-id: ${POD_NAME:${HOSTNAME:${random.value}}}
  cache:
    ttl-seconds: 3600  # 1 hour redis  TTL for PSP result cache
  payment-service:
    api-key: secretpaymentapikey12345

  kafka: # Kafka configuration for dynamic consumers
    dynamic-consumers:
      - id: payment-order-enqueuer
        topic: payment_order_created_topic
        group-id: payment-order-enqueuer-consumer-group
        class-name: com.dogancaglar.paymentservice.port.inbound.consumers.PaymentOrderEnqueuer
        concurrency: 4

      - id: payment-order-psp-call-executor
        topic: payment_order_psp_call_requested_topic
        group-id: payment-order-psp-call-executor-consumer-group
        class-name: com.dogancaglar.paymentservice.port.inbound.consumers.PaymentOrderPspCallExecutor
        concurrency: 8

      - id: payment-order-psp-result-applier
        topic: payment_order_psp_result_updated_topic
        group-id: payment-order-psp-result-updated-consumer-group
        class-name: com.dogancaglar.paymentservice.port.inbound.consumers.PaymentOrderPspResultApplier
        concurrency: 8

      - id: payment-status-check-executor-scheduler
        topic: payment_status_check_scheduler_topic
        group-id: payment-status-check-scheduler-consumer-group
        class-name: com.dogancaglar.paymentservice.port.inbound.consumers.ScheduledPaymentStatusCheckExecutor
        concurrency: 1
server:
  port: 8080
  tomcat:
    accesslog:
      enabled: true
      directory: /var/log/tomcat
      prefix: access_log
      suffix: .log
      pattern: '%h %l %u %t "%r" %s %b %D'
      buffered: true
spring:
  datasource:
    url: ${SPRING_DATASOURCE_URL}
    username: ${SPRING_DATASOURCE_USERNAME} # This will be injected from a Kubernetes Secret
    password: ${SPRING_DATASOURCE_PASSWORD}
    hikari:
      maximum-pool-size: 5          # was 3
      minimum-idle: 1               # 0 → 1 keeps 1 warm without hoarding
      connection-timeout: 1500      # 1.5s is tight but keeps callers from piling up
      validation-timeout: 1000
      idle-timeout: 600000          # 10m
      max-lifetime: 1740000         # 29m (slightly < 30m to avoid herd reaps)
      keepalive-time: 300000        # 5m, prevents LB/NAT idle drops (Hikari option)
      leak-detection-threshold: 60000   # optional; logs if a checkout > 60s
  kafka:
    consumer:
      max-poll-records: 200
      fetch-min-bytes: 262144      #  256k before broker responds (latency vs efficiency)
      fetch-max-wait: 25ms            # cap the wait so latency doesn’t spike
      # Per-partition and total fetch caps (keep under broker limits)
      max-partition-fetch-bytes: 1048576   # 4 MiB
      fetch-max-bytes: 33554432
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
      properties:
        spring.deserializer.value.delegate.class: com.dogancaglar.paymentservice.config.kafka.EventEnvelopeKafkaDeserializer
        partition.assignment.strategy: org.apache.kafka.clients.consumer.CooperativeStickyAssignor
    properties:
      security.protocol: PLAINTEXT
      session.timeout.ms: 45000
  data:
    redis:
      url: redis://redis-master:6379
      timeout: 2s
management:
  health:
    probes:
      enabled: true
  endpoints:
    web.exposure.include: "prometheus,metrics,health"
  endpoint:
    health:
      enabled: true
      show-details: always
    prometheus.enabled: true
  metrics:
    tags:
      application: payment-consumers
    enable:
      all: false
      hikaricp.connections: true
      hikaricp.connections.acquire: true
      kafka.consumer.fetch.manager.records.lag: true
      kafka.producer.topic.record.send: true
      kafka.consumer.fetch.manager.records.consumed: true
      kafka.consumer.fetch.manager.fetch.latency: true
      kafka.consumer.io.time: true
      process.cpu.usage: true
      jvm.threads.live: true
      jvm.memory.used: true
      jvm.memory.max: true
      jvm.gc.pause: true
      # binders

      # your custom meters (base names)
      psp_calls_total: true
      psp_call_latency: true
      psp_queue_delay: true
      psp_exec_duration: true
      redis_retry_zset_size: true
      redis_retry_batch_size: true
      redis_retry_events_total: true
      redis_retry_dispatch_batch_seconds: true
      redis_retry_dispatch_event_seconds: true
    distribution:
      # timers you want histograms for (you already call publishPercentileHistogram() in code,
      # this just makes it explicit in config too)
      percentiles-histogram:
        psp_call_latency: true
        redis_retry_dispatch_batch_seconds: true
        redis_retry_dispatch_event_seconds: true
      percentiles:
        psp_call_latency: 0.5,0.95,0.99
        redis_retry_dispatch_batch_seconds: 0.5,0.95,0.99
        redis_retry_dispatch_event_seconds: 0.5,0.95,0.99
    export:
      prometheus:
        enabled: true

psp:
  simulation:
    currentScenario: NORMAL
    scenarios:
      NORMAL:
        timeouts:
          enabled: true
          probability: 20       # 2% of total requests time out
        latency:
          fast:
            probability: 100    # rest of 100% are fast (50–150ms)
            minMs: 50
            maxMs: 150
          moderate:
            probability: 0    # 0% are moderate (150–300ms)
            minMs: 150
            maxMs: 300
          slow:
            probability: 0     # 0% are slow (300–600ms)
            minMs: 300
            maxMs: 600
        response:
          successful: 70
          retryable: 20
          statusCheck: 0
          nonRetryable: 10
      PEAK:
        timeouts:
          enabled: true
          probability: 25      # 25% timeouts
        latency:
          fast:
            probability: 30    # 30% fast (250–500ms)
            minMs: 250
            maxMs: 500
          moderate:
            probability: 50    # 50% moderate (501–1500ms)
            minMs: 501
            maxMs: 1500
          slow:
            probability: 20    # 20% slow (1501–2500ms)
            minMs: 1501
            maxMs: 2500
        response:
          successful: 50
          retryable: 45
          statusCheck: 0
          nonRetryable: 5
      DEGRADED:
        timeouts:
          enabled: true
          probability: 30      # 30% timeouts
        latency:
          fast:
            probability: 20    # 20% fast (2000–2200ms)
            minMs: 2000
            maxMs: 2200
          moderate:
            probability: 20    # 20% moderate (2201–2600ms)
            minMs: 2201
            maxMs: 2600
          slow:
            probability: 60    # 60% slow (2601–2990ms)
            minMs: 2601
            maxMs: 2990
        response:
          successful: 50
          retryable: 40
          statusCheck: 0
          nonRetryable: 10
      BEST_PSP_EVER:
        timeouts:
          enabled: false
          probability: 0
        latency:
          fast:
            probability: 100   # 100% fast (1–2ms)
            minMs: 1
            maxMs: 2
          moderate:
            probability: 0
            minMs: 0
            maxMs: 0
          slow:
            probability: 0
            minMs: 0
            maxMs: 0
        response:
          successful: 100
          retryable: 0
          statusCheck: 0
          nonRetryable: 0
