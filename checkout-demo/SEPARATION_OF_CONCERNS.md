# Separation of Concerns Analysis: Browser vs Proxy Server

## Current Architecture

### Browser (React App) - `src/App.jsx` & `src/services/paymentService.js`
**Current Responsibilities:**
- ✅ UI/UX for shopper (form, payment element, loading states)
- ✅ Client-side form validation
- ✅ Payment flow state management
- ✅ Stripe Payment Element integration
- ✅ Error handling and user feedback
- ✅ Retry logic for 409 conflicts
- ✅ Polling logic for payment status
- ✅ HTTP status code handling (201, 200, 202, 409)

### Proxy Server (Node.js) - `server.js`
**Current Responsibilities:**
- ✅ Keycloak token acquisition (server-to-server)
- ✅ Authentication with payment-service
- ✅ Request forwarding to payment-service
- ✅ CORS handling
- ✅ Security (hiding credentials from browser)
- ⚠️ **Idempotency key generation** (should be browser responsibility)
- ⚠️ **Request validation** (duplicated - browser also validates)
- ⚠️ **Response wrapping** (adds `_meta` that browser doesn't use)
- ❌ **Doesn't preserve HTTP status codes** (always returns 200 for success)
- ❌ **Doesn't preserve headers** (Retry-After, Location, Idempotent-Replayed)

---

## Proper Separation of Concerns

### Browser Should Handle:
1. **Idempotency Key Generation**
   - Browser should generate and send idempotency key
   - Allows client to control retry behavior
   - Current: Proxy generates it (line 324)

2. **Request Validation (Client-Side)**
   - Basic validation before sending to server
   - Current: Both browser and proxy validate (redundant)

3. **HTTP Status Code Handling**
   - Browser should receive actual HTTP status codes
   - Current: Proxy always returns 200 for success

4. **Response Header Handling**
   - Browser should receive Retry-After, Location, Idempotent-Replayed
   - Current: Headers are lost

5. **User Experience**
   - Loading states, error messages, retry logic
   - Payment flow orchestration

### Proxy Server Should Handle:
1. **Security & Authentication**
   - Keycloak token acquisition (server-to-server)
   - Adding Authorization header
   - Hiding credentials from browser

2. **Request Forwarding**
   - Forward requests to payment-service
   - Handle network errors and timeouts
   - Preserve HTTP status codes and headers

3. **CORS Handling**
   - Enable CORS for browser requests

4. **Error Transformation (Optional)**
   - Transform backend errors to user-friendly messages
   - Log errors server-side

5. **Request Validation (Server-Side)**
   - Security validation (prevent malicious requests)
   - Current: Basic validation (could be improved)

---

## Issues with Current Implementation

### Issue 1: HTTP Status Codes Lost
**Problem:**
```javascript
// Proxy always returns 200, even if backend returns 201/202/409
res.json(response);  // No status code set = defaults to 200
```

**Impact:**
- Browser can't distinguish between 201 (created) and 202 (accepted)
- Browser can't handle 409 conflicts properly
- Frontend has to check response body instead of HTTP status

**Fix:**
```javascript
res.status(paymentResponse.status).json(response);
```

### Issue 2: Headers Lost
**Problem:**
- Retry-After header not forwarded
- Location header not forwarded
- Idempotent-Replayed header not forwarded

**Impact:**
- Browser can't use Retry-After for automatic retries
- Browser can't use Location header for resource navigation
- Browser can't detect idempotent replays

**Fix:**
```javascript
// Forward important headers
const headers = {
  'retry-after': paymentResponse.headers.get('retry-after'),
  'location': paymentResponse.headers.get('location'),
  'idempotent-replayed': paymentResponse.headers.get('idempotent-replayed')
};
res.status(paymentResponse.status)
   .set(headers)
   .json(response);
```

### Issue 3: Idempotency Key Generated by Proxy
**Problem:**
```javascript
// Proxy generates idempotency key (line 324)
const idempotencyKey = randomUUID();
```

**Impact:**
- Browser can't control retry behavior
- Each request gets new key (defeats idempotency purpose)
- Browser can't implement proper retry logic

**Fix:**
- Browser should generate idempotency key
- Browser should send it in request
- Proxy should forward it to payment-service

### Issue 4: Unused Metadata
**Problem:**
```javascript
// Proxy adds _meta that browser never uses
_meta: {
  token: token,
  idempotencyKey: idempotencyKey,
  usedApiUrl: paymentUrl,
  usedHostHeader: PAYMENT_API_HOST_HEADER
}
```

**Impact:**
- Unnecessary data transfer
- Confusion about what data is needed

**Fix:**
- Remove _meta or only include it for debugging

### Issue 5: Duplicate Validation
**Problem:**
- Browser validates form (required fields)
- Proxy also validates (orderId, buyerId)

**Impact:**
- Redundant code
- Inconsistent validation messages

**Fix:**
- Browser: Client-side UX validation
- Proxy: Security validation (prevent malicious requests)

---

## Recommended Changes

### 1. Fix Proxy to Preserve Status Codes and Headers

```javascript
// In process-payment endpoint
if (!paymentResponse.ok) {
  return res.status(paymentResponse.status).json({
    error: 'Payment service request failed',
    status: paymentResponse.status,
    statusText: paymentResponse.statusText,
    details: paymentResponseData
  });
}

// Forward important headers
const headers = {};
const retryAfter = paymentResponse.headers.get('retry-after');
const location = paymentResponse.headers.get('location');
const idempotentReplayed = paymentResponse.headers.get('idempotent-replayed');

if (retryAfter) headers['retry-after'] = retryAfter;
if (location) headers['location'] = location;
if (idempotentReplayed) headers['idempotent-replayed'] = idempotentReplayed;

res.status(paymentResponse.status)
   .set(headers)
   .json({
     payment: paymentResponseData
   });
```

### 2. Move Idempotency Key Generation to Browser

```javascript
// In browser (paymentService.js)
export async function createPayment(paymentData, idempotencyKey) {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Idempotency-Key': idempotencyKey  // Browser sends it
    },
    body: JSON.stringify(paymentData),
  });
  // ...
}

// In browser (App.jsx)
const idempotencyKey = crypto.randomUUID();  // Browser generates
await createPayment(paymentRequest, idempotencyKey);
```

```javascript
// In proxy (server.js)
// Remove idempotency key generation
// Forward idempotency key from request header
const idempotencyKey = req.headers['idempotency-key'];
if (!idempotencyKey) {
  return res.status(400).json({
    error: 'Idempotency-Key header required'
  });
}
```

### 3. Remove Unused Metadata

```javascript
// In proxy - remove _meta or make it optional
res.status(paymentResponse.status)
   .set(headers)
   .json({
     payment: paymentResponseData
     // Remove _meta unless needed for debugging
   });
```

### 4. Clarify Validation Responsibilities

**Browser:**
- UX validation (required fields, format)
- Immediate feedback to user

**Proxy:**
- Security validation (prevent injection, size limits)
- Business rule validation (if needed)

---

## Summary

### Current State: ⚠️ Mixed Concerns
- Proxy handles too much (idempotency, validation)
- Proxy loses important information (status codes, headers)
- Browser can't fully control retry behavior

### Recommended State: ✅ Clear Separation
- **Browser:** User experience, idempotency control, retry logic
- **Proxy:** Security, authentication, request forwarding, header/status preservation

### Priority Fixes:
1. **HIGH:** Preserve HTTP status codes in proxy
2. **HIGH:** Preserve headers (Retry-After, Location) in proxy
3. **MEDIUM:** Move idempotency key generation to browser
4. **LOW:** Remove unused _meta
5. **LOW:** Clarify validation responsibilities

